<!doctype html>
<html>

<head>
  <title>Netflix - Interactive Analysis</title>

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
    }

    .chart {
      width: 900px;
      height: 600px;
      background-color: #f7f7f7;
      border: 1px solid #ccc;
      border: 1px solid #f7f7f7;
      display: none;
    }

    .active {
      display: block;
    }

    .button-container {
      margin-bottom: 10px;
    }

    .button {
      padding: 10px 20px;
      font-size: 16px;
      font-weight: bold;
      border: none;
      border-radius: 5px;
      background-color: #4CAF50;
      color: #fff;
      cursor: pointer;
      margin-right: 10px;
    }

    .button:hover {
      background-color: #45a049;
    }

    .button:active {
      background-color: #3d8e41;
    }

    .tooltip {
      position: absolute;
      padding: 8px;
      background-color: rgba(0, 0, 0, 0.7);
      color: #fff;
      font-size: 12px;
      pointer-events: none;
    }

    svg {
      width: 900px;
      height: 600px;
    }
  </style>


</head>

<body>
  <h1 class="display-4"> Let's explore Netflix!</h1>
  <div class="button-container">
    <button class="button" onclick="showChart(1)">1</button>
    <button class="button" onclick="showChart(2)">2</button>
    <button class="button" onclick="showChart(3)">3</button>
    <button class="button" onclick="showChart(4)">4</button>
  </div>
  <div class="chart" id="chart1"></div>
  <div class="chart" id="chart2"></div>
  <div class="chart" id="chart3"></div>
  <div class="chart" id="chart4"></div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    // Show the specified chart based on the button click
    function showChart(chartNumber) {
      // Hide all charts
      d3.selectAll('.chart').style('display', 'none');

      // Show the selected chart
      const selectedChart = d3.select(`#chart${chartNumber}`);
      selectedChart.style('display', 'block');

      // Generate the chart content based on the selected chart number
      generateChartContent(selectedChart, chartNumber);
    }

    // Generate the content for each chart based on the chart number
    function generateChartContent(chart, chartNumber) {
      // Clear existing content
      chart.html('');


      // Generate content based on the chart number
      switch (chartNumber) {
        case 1:
          //chart.append('p').text('Pie Chart');

          const data = [
            { 'category': 'International TV Shows', 'count': 966 },
            { 'category': 'Korean TV Shows', 'count': 120 },
            { 'category': 'Romantic TV Shows', 'count': 265 },
            { 'category': 'Documentaries', 'count': 658 },
            { 'category': 'International Movies', 'count': 1797 },
            { 'category': 'Comedies', 'count': 992 },
            { 'category': 'Dramas', 'count': 1488 },
            { 'category': 'Independent Movies', 'count': 516 },
            { 'category': "Kids' TV", 'count': 313 },
            { 'category': 'Thrillers', 'count': 353 },
            { 'category': 'Crime TV Shows', 'count': 355 },
            { 'category': 'Spanish-Language TV Shows', 'count': 114 },
            { 'category': 'Reality TV', 'count': 146 },
            { 'category': 'Action & Adventure', 'count': 532 },
            { 'category': 'TV Comedies', 'count': 425 },
            { 'category': 'Docuseries', 'count': 271 },
            { 'category': 'Children & Family Movies', 'count': 340 },
            { 'category': 'Anime Series', 'count': 111 },
            { 'category': 'Stand-Up Comedy & Talk Shows', 'count': 42 },
            { 'category': 'TV Dramas', 'count': 574 },
            { 'category': 'Romantic Movies', 'count': 338 },
            { 'category': 'Stand-Up Comedy', 'count': 273 },
            { 'category': 'Movies', 'count': 55 },
            { 'category': 'TV Mysteries', 'count': 66 },
            { 'category': 'Classic Movies', 'count': 65 },
            { 'category': 'TV Sci-Fi & Fantasy', 'count': 66 },
            { 'category': 'Sci-Fi & Fantasy', 'count': 165 },
            { 'category': 'Anime Features', 'count': 41 },
            { 'category': 'Sports Movies', 'count': 149 },
            { 'category': 'TV Action & Adventure', 'count': 122 },
            { 'category': 'Cult Movies', 'count': 42 },
            { 'category': 'Horror Movies', 'count': 229 },
            { 'category': 'Teen TV Shows', 'count': 41 },
            { 'category': 'British TV Shows', 'count': 205 },
            { 'category': 'Music & Musicals', 'count': 229 },
            { 'category': 'LGBTQ Movies', 'count': 59 },
            { 'category': 'Science & Nature TV', 'count': 66 },
            { 'category': 'Faith & Spirituality', 'count': 46 },
            { 'category': 'TV Horror', 'count': 51 },
            { 'category': 'TV Thrillers', 'count': 43 },
            { 'category': 'Classic & Cult TV', 'count': 24 },
            { 'category': 'TV Shows', 'count': 10 },
          ];

          const width = 900;
          const height = 600;
          const svg = d3.select("#chart1")
            .append("svg")
            .attr("width", width)
            .attr("height", height);

          const netflixColors = [
            "#69A094",
            "#A3DDCE",
            "#B63678",
            "#12E3EA",
            "#E7742F",
            "#1ED9E6",
            "#54AAD4",
            "#62EBCD",
            "#2E971A",
            "#B2E002",
            "#8089AF",
            "#B444C0",
            "#3A05F9",
            "#AFCA50",
            "#4996C0",
            "#D4C6E0",
            "#6B8D6A",
            "#B2B263",
            "#CF9751",
            "#A2A211",
            "#EC9CFA",
            "#A4FA25",
            "#3415D4"
          ];

          const color = d3.scaleOrdinal().range(netflixColors);

          const pack = data => d3.pack()
            .size([width, height])
            .padding(10) // Adjust the padding to increase bubble size
            (d3.hierarchy({ children: data })
              .sum(d => d.count));

          const root = pack(data);

          const node = svg.selectAll("circle")
            .data(root.leaves())
            .join("circle")
            .attr("class", "node")
            .attr("cx", d => d.x)
            .attr("cy", d => d.y)
            .attr("r", d => d.r)
            .attr("fill", d => color(d.data.category))
            .on("mouseover", function (event, d) {
              d3.select(this).attr("fill", "#E50914")
                .transition()
                .duration(100)
                .attr("r", d => d.r + 10);
              tooltip.style("opacity", 1)
                .html(`${d.data.category}: ${d.data.count}`)
                .attr("x", width - 10) // Set x position of tooltip (right corner)
                .attr("y", 15) // Set y position of tooltip (top corner)
                .style("text-anchor", "end") // Align text to the right
                .style("pointer-events", "none") // Prevent tooltip from blocking mouse interactions
                .style("font-size", "16px");


            })
            .on("mouseout", function (event, d) {
              d3.select(this).attr("fill", d => color(d.data.category))
                .transition()
                .duration(100)
                .attr("r", d => d.r);

              tooltip.style("opacity", 0);

  
            });

          // Add labels to the bubbles
          const labels = svg.selectAll("text")
            .data(root.leaves())
            .join("text")
            .attr("class", "label")
            .attr("x", d => d.x)
            .attr("y", d => d.y)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "middle")
            .attr("fill", "#000")
            .style("font-size", "12px")
            .text(d => d.data.category);

          // Add tooltip element within the chart
          const tooltip = svg.append("text")
            .attr("class", "tooltip")
            .style("opacity", 0);

          break;

        case 2:
          const data2 = [
            { year: 2008, type: "TV Show", count: 1 },
            { year: 2008, type: "Movie", count: 1 },
            { year: 2009, type: "Movie", count: 2 },
            { year: 2010, type: "Movie", count: 1 },
            { year: 2011, type: "TV Show", count: 25 },
            { year: 2011, type: "Movie", count: 13 },
            { year: 2012, type: "TV Show", count: 3 },
            { year: 2012, type: "Movie", count: 4 },
            { year: 2013, type: "TV Show", count: 3 },
            { year: 2013, type: "Movie", count: 6 },
            { year: 2014, type: "Movie", count: 19 },
            { year: 2015, type: "TV Show", count: 6 },
            { year: 2015, type: "Movie", count: 58 },
            { year: 2016, type: "TV Show", count: 148 },
            { year: 2016, type: "Movie", count: 264 },
            { year: 2017, type: "TV Show", count: 271 },
            { year: 2017, type: "Movie", count: 913 },
            { year: 2018, type: "TV Show", count: 339 },
            { year: 2018, type: "Movie", count: 1290 },
            { year: 2019, type: "TV Show", count: 476 },
            { year: 2019, type: "Movie", count: 1367 },
          ];

          const margin = { top: 20, right: 20, bottom: 50, left: 50 };
          const width2 = 600 - margin.left - margin.right;
          const height2 = 400 - margin.top - margin.bottom;

          const xScale2 = d3.scaleLinear()
            .domain(d3.extent(data2, d => d.year))
            .range([0, width2]);

          const yScale2 = d3.scaleLinear()
            .domain([0, d3.max(data2, d => d.count)])
            .range([height2, 0]);

          const colorScale2 = d3.scaleOrdinal()
            .domain(["TV Show", "Movie"])
            .range(["#a678de", "#6ad49b"]);

          const svg2 = d3.select("#chart2")
            .append("svg")
            .attr("width", width2 + margin.left + margin.right)
            .attr("height", height2 + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

          const tooltip2 = d3.select("#chart2")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

          // Separate the data by type
          const dataTVShow = data2.filter(d => d.type === "TV Show");
          const dataMovie = data2.filter(d => d.type === "Movie");

          // Create line generators for each category
          const lineTVShow = d3.line()
            .x(d => xScale2(d.year))
            .y(d => yScale2(d.count));

          const lineMovie = d3.line()
            .x(d => xScale2(d.year))
            .y(d => yScale2(d.count));

          // Append the lines
          svg2.append("path")
            .datum(dataTVShow)
            .attr("fill", "none")
            .attr("stroke", "#a678de")
            .attr("stroke-width", 2)
            .attr("d", lineTVShow);

          svg2.append("path")
            .datum(dataMovie)
            .attr("fill", "none")
            .attr("stroke", "#6ad49b")
            .attr("stroke-width", 2)
            .attr("d", lineMovie);

          // Append the circles
          const circles2 = svg2.selectAll("circle")
            .data(data2)
            .join("circle")
            .attr("cx", d => xScale2(d.year))
            .attr("cy", d => yScale2(d.count))
            .attr("r", 5)
            .attr("fill", d => colorScale2(d.type))
            .on("mouseover", (event, d) => {
              d3.select(event.currentTarget).attr("fill", "#ff7f0e");
              tooltip2.style("opacity", 1)
                .html(`Year: ${d.year}<br>Number Added: ${d.count}<br>Type: ${d.type}`)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY + 10) + "px");
            })
            .on("mouseout", (event, d) => {
              d3.select(event.currentTarget).attr("fill", colorScale2(d.type));
              tooltip2.style("opacity", 0);
            });

          const xAxis2 = d3.axisBottom(xScale2)
            .tickFormat(d3.format("d"));

          const yAxis2 = d3.axisLeft(yScale2);

          svg2.append("g")
            .attr("transform", `translate(0,${height2})`)
            .call(xAxis2);

          svg2.append("g")
            .call(yAxis2);

          break;

        case 3:
          const data4 = [
            { country: "USA", content: 2430 },
            { country: "India", content: 345 },
            { country: "UK", content: 34 },
            { country: "France", content: 225 },
            { country: "Canada", content: 14 }
          ];

          data4.sort((a, b) => b.content - a.content); // Sort the data in descending order

          const margin4 = { top: 20, right: 20, bottom: 50, left: 100 };
          const width4 = 600 - margin4.left - margin4.right;
          const height4 = 400 - margin4.top - margin4.bottom;

          const svg4 = chart.append("svg")
            .attr("width", width4 + margin4.left + margin4.right)
            .attr("height", height4 + margin4.top + margin4.bottom)
            .append("g")
            .attr("transform", `translate(${margin4.left},${margin4.top})`);

          const xScale4 = d3.scaleLinear()
            .domain([0, d3.max(data4, d => d.content)])
            .range([0, width4]);

          const yScale4 = d3.scaleBand()
            .domain(data4.map(d => d.country))
            .range([0, height4])
            .padding(0.1);

          const tooltip4 = d3.select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

          const bars4 = svg4.selectAll("rect")
            .data(data4)
            .enter()
            .append("rect")
            .attr("x", 0)
            .attr("y", d => yScale4(d.country))
            .attr("width", d => xScale4(d.content))
            .attr("height", yScale4.bandwidth())
            .attr("fill", "#6ad49b")
            .on("mouseover", (event, d) => {
              d3.select(event.currentTarget).attr("fill", "#ff7f0e");
              tooltip4.style("opacity", 1)
                .html(`Country: ${d.country}<br>Content: ${d.content}`)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY + 10) + "px");
            })
            .on("mouseout", (event, d) => {
              d3.select(event.currentTarget).attr("fill", "#6ad49b");
              tooltip4.style("opacity", 0);
            });

          const xAxis4 = d3.axisBottom(xScale4);

          svg4.append("g")
            .attr("transform", `translate(0,${height4})`)
            .call(xAxis4);

          const yAxis4 = d3.axisLeft(yScale4);

          svg4.append("g")
            .call(yAxis4);

          break;

        case 4:
          const geojson = {
            type: "FeatureCollection",
            features: [
              { type: "Feature", properties: { name: "Country A" }, geometry: { type: "Polygon", coordinates: [[[-10, -10], [10, -10], [10, 10], [-10, 10], [-10, -10]]] } },
              { type: "Feature", properties: { name: "Country B" }, geometry: { type: "Polygon", coordinates: [[[-10, -10], [10, -10], [10, 10], [-10, 10], [-10, -10]]] } },
              { type: "Feature", properties: { name: "Country C" }, geometry: { type: "Polygon", coordinates: [[[-10, -10], [10, -10], [10, 10], [-10, 10], [-10, -10]]] } }
            ]
          };

          // Get the data for the number of content from each country
          const data3 = [
            { country: "Country A", count: 10 },
            { country: "Country B", count: 20 },
            { country: "Country C", count: 5 }
            // Add more data points...
          ];

          // Set up the map dimensions
          const width3 = 900;
          const height3 = 600;

          // Create an SVG element
          const svg3 = d3.select("#chart3")
            .append("svg")
            .attr("width", width3)
            .attr("height", height3);

          // Create a projection for the map
          const projection = d3.geoMercator()
            .fitSize([width3, height3], geojson);

          // Create a path generator
          const path = d3.geoPath()
            .projection(projection);

          // Set up a color scale for the choropleth map
          const colorScale3 = d3.scaleSequential(d3.interpolateBlues)
            .domain([0, d3.max(data3, d => d.count)]);

          // Add the country shapes to the map
          svg3.selectAll("path")
            .data(geojson.features)
            .enter()
            .append("path")
            .attr("d", path)
            .attr("fill", d => {
              // Find the matching data for each country
              const countryData = data3.find(data => data.country === d.properties.name);
              // Use the color scale for the fill color based on the count
              return colorScale3(countryData.count);
            })
            .on("mouseover", (event, d) => {
              const countryData = data3.find(data => data.country === d.properties.name);
              d3.select(event.currentTarget).attr("fill", "#ff7f0e");
              tooltip3.style("opacity", 1)
                .html(`${d.properties.name}: ${countryData.count}`)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY + 10) + "px");
            })
            .on("mouseout", (event, d) => {
              const countryData = data3.find(data => data.country === d.properties.name);
              d3.select(event.currentTarget).attr("fill", colorScale3(countryData.count));
              tooltip3.style("opacity", 0);
            });

          // Add tooltip element
          const tooltip3 = d3.select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

          break;

        default:

          chart.append('p').text('No chart content available');
      }
    }
  </script>
</body>

</html>